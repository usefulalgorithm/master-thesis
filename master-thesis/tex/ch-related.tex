\chapter{Related Works}\label{ch:related}

Exact automata learning algorithm was first proposed by Angluin \cite{Angluin87}, and later improved by \cite{Angluin87,RivestS93,KearnsV94,BolligHKL09}. The concept of probably approximately correct (PAC) learning was first proposed by Valiant in his seminal work \cite{Valiant84}. The idea of turning an exact learning algorithm to a PAC learning algorithm can be found in Section 1.2 of \cite{Angluin88}.

Applying PAC learning to testing has been considered before \cite{Walkinshaw11,GoldreichGR98}. The work in \cite{GoldreichGR98} considers a program that manipulates graphs and check if the output graph has certain properties such as bipartite, $k$-colorable, etc. Our work considers assertion checking, which is more general than the specialized properties. The work in \cite{Walkinshaw11} leans more towards the theoretical aspects of the problem. The author estimates the maximal number of queries required to infer a model of a black-box machine. The context is quite different, e.g., the work does not discuss how to sample according to some distribution efficiently to produce the desired guarantee (bounded path coverage) as we do in this paper. 

The $L^\ast$ algorithm has been used to infer the model of error traces of a program. In \cite{ChapmanCKKST15}, instead of decision vectors, the authors try to learn the sequences of function calls leading to an error. However, the teacher in this work is implemented using a bounded model checker, hence can only guarantee correctness up to a given bound. The author do not make use of the PAC learning mechanism as we did in this work. 

Both our approach and statistical model checking \cite{SenVA04,LegayDB10,ZulianiPC13} provide statistical guarantees. Statistical model checking assumes a given model, while our mechanism generates models of programs with statistical guarantee. Those models can be analyzed using various techniques and reused for verifying different properties.

We implemented a prototype tool called \textsc{Pac-Man} based on this work. In the implementation, we used several off-the-shelf software model checkers, \textsc{CPAchecker} \cite{BeyerK11}, \textsc{CBMC} \cite{ClarkeKL04}, \textsc{Predator} \cite{DudkaPV11}, and \textsc{SeaHorn} \cite{GurfinkelKKN15} to decide the feasibility of the program execution traces. Also, we have used two third-party libraries, namely \textsc{libALF} \cite{BolligKKLNP10} and \textsc{libAMoRE++} \cite{MatzMPTV95}, to perform the operations on automata. Moreover, we used C Intermediate Language (CIL) \cite{NeculaMRW02} \cite{cil} to perform program transformations. Last but not least, we used the concolic tester \textsc{Crest} \cite{BurnimS08} to sample from the targeet program. 

We submitted the prototype tool to participate in SV-COMP 2016 \cite{svcomp16}. In particular, our tool ranked $4^{th}$ in both the Recursive and ArrayReach subcategories 


\begin{comment}
Numerous intraprocedural analysis techniques have been developed over the years.
Many tools are in fact freely available (see, for instance,
\textsc{Blast}~\cite{BeyerHJM07}, \textsc{CPAchecker}~\cite{BeyerK11}, and
\textsc{UFO}~\cite{AlbarghouthiLGC12}).
Interprocedural analysis techniques are also available (see~\cite{RepsHS95,
BallR01,CousotCFMMMR05,CuoqKKPSY12,coverity,polyspace} for a partial list).
Recently, recursive analysis attracts new attention.
The Competition on Software Verification adds a new category for recursive
programs in 2014~\cite{svcomp14}.
Among the participants, \textsc{CBMC}~\cite{ClarkeKL04},
\textsc{Ultimate Automizer}~\cite{HeizmannCDEHLNSP13}, and
\textsc{Ultimiate Kojak}~\cite{ErmisNDHP14} are the top three tools for the
\textbf{recursive} category.

Inspired by \textsc{Whale}~\cite{AlbarghouthiGC12}, we use inductive invariants
obtained from verifying under-approximation as candidates of summaries.
Also, similar to \textsc{Whale}, we apply a Hoare logic proof rule for recursive
calls from~\cite{Oheimb99}.
However, our technique works on control flow graphs and builds on an
intraprocedural analysis tool.
It is hence very lightweight and modular.
Better intraprocedural analysis tools easily give better recursive analysis
through our technique.
\textsc{Whale}, on the other hand, analyzes by exploring abstract reachability
graphs.
Since \textsc{Whale} extends summary computation and covering relations for
recursion, its implementation is more involved.

Aside from recursion analysis, using program transformation to reduce program
features is not a new concept.
We learned this concept particularly from~\cite{LalR08,LalR09},
where a program transformation technique for checking context-bounded concurrent
programs to sequential analysis is developed.
\end{comment}

