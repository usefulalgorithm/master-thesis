\chapter{Handling Procedure Calls}\label{ch:procedure_calls}

As mentioned in \ref{sec:model}, we can extend our formalism of CFGs to handle programs with multiple procedures. In contrast to the previous setting where we use finite automata to represent an approximations to the set of error decision vectors, we use \emph{Pushdown Automata} (PDA) instead. A prominent issue of using finite automata to represent error decision vectors in a program with multiple procedures is that when returning from a procedure call, a finite automaton cannot keep track of an unbounded number of return points (in the case of recursive procedures). An overapproximation, such as a nondeterministic jump to any possible return point, needs to be adopted. Such overapproximation is however too imprecise and yields too much spurious errors. On the other hand, PDAs provide better precision when it comes to representing the set of error decision vectors. 

However, we still use a finite automaton to represent $\DEC(\Pi)$, the set of feasible decision vectors. Therefore all components remain unchanged for the setting of multiple procedures, except that we need to apply PDA operations instead of finite automaton operations and handle procedure calls in membership queries. 

\section{Extending CFGs with Procedure Calls}\label{sec:extend_cfg}

Assume the set of procedure names $\mathcal{P}$. A \emph{CFG with calls} (CGFC) is defined as a graph $G = (V, E, v_i, v_r, V_e, \mathcal{X}_{FP})$, where $V, v_i, v_r, V_e,$ and $\mathcal{X}_{FP}$ are defined in the same manner as for a CFG (cf. \ref{sec:model}), and $E \subseteq (V \times \mathcal{T[X,F]}) \times V) \cup (V \times \mathcal{P \times T[X,F] \times T[X,F] }) \times V)$ is an extended set of edges, such that in addition to local CFG edges $(v, f, v')$ for $f \in \mathcal{T[X,F]}$ it also contains \emph{procedure call edges} $e = (v, (p, g_{in}, g_{out}), v')$ for $(p, g_{in}, g_{out}) \in \mathcal{P \times T[X,F] \times T[X,F] }$ and sequential nodes $v$. $g_{in}$ and $g_{out}$ of $e$ corresponds to formulae for passing actual values to formal parameters of $p$ (formula $g_{in}$), and passing the return values of $p$ to the caller procedure (formula $g_{out}$).

In this scenario, we define a \emph{program} as a set of CFGCs $prog = {G_1, \dots, G_n}$ along with a bijective mapping $cfgc_{prog} : \mathcal{P} \mapsto prog$ that assigns procedure names to CFGCs. We abuse this notation and use $prog$ to denote $cfgc_{prog}$, i.e. $prog(p)$ denotes the CFGC of a procedure $p$ in a program $prog$. We then assume that all CFGCs in $prog$ have pairwise disjoint set of nodes, and furthur assume an entry point $\mathtt{main} \in \mathcal{P}$. 

We then give an intuitive description of how we extend the definition of a path from a program consisting of single CFG to a program consisting of a set of CFGCs and a dedicated entry point. Given a procedure call edge $e$ in a CFGC $G$, we call the \emph{inlining} of $e$ in $G$ the CFGC $G'$ obtained from $G$ by substituting $e$ with the CFGC of the called procedure. We use $[\![prog]\!]$ to denote the set of CFGs obtained from $prog(\mathtt{main})$ by performing all possible (even recursively called) sequences of inlinings, and removing any left procedure call edges from the output CFGCs. A \emph{path} in $prog$ is then a sequence $\pi = \langle v_0, f_1, v_1, f_2, v_2, \dots , f_m, v_m \rangle$ such that there exists a CFG $G' \in [\![prog]\!]$ for which it holds that $\pi \in G'$. 