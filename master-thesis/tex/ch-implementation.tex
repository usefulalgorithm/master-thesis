\chapter{Implementation}\label{ch:implementation}

We created a prototype tool \PACMAN that implements the two procedures described in this paper. More specifically, \PACMAN supports two modes: \emph{synthesize-and-verify} and \emph{direct}, corresponding to the learning-based and the sampling-based procedure respectively. In the following sections, detailed descriptions of each procedure will be given.

\section{The Learning-Based Procedure}\label{sec:impl_learning}

In the synthesize-and-verify mode, we utilize several third-party libraries and tools. First, it uses CIL (C Intermediate Language) \cite{NeculaMRW02}, \cite{cil} to convert the program-under-test, which is a C program, to a set of CFGC's. We then construct the error trace pushdown automaton $B_P$ based on the set of CFGC's. Furthermore, we use the library \textsc{libAMoRE++} \cite{MatzMPTV95}, \cite{BolligKKLNP10} to perform operations on automata, i.e. checking for membership and emptiness, or computing intersections. 

For learning automata, we use the implementation of various learning algorithms within the \textsc{libALF} library \cite{BolligKKLNP10}. Membership queries are discharged using a concolic tester, mentioned as an alternative option in Chapter \ref{ch:mem}. Given a decision vector, \PACMAN uses the CFG of the program to generate a path corresponding to the decision vector. The path then is passed in the form of a sequence of program statements to a readily available software model checker to check the path's feasibility. In our implementation, we've used several software model checkers, including \textsc{CPAchecker} \cite{BeyerK11}, CBMC \cite{ClarkeKL04}, Predator \cite{DudkaPV11} and SeaHorn \cite{GurfinkelKKN15}.

On the other hand, equivalence queries are discharged by utilizing a modified version of the concolic tester \textsc{Crest} \cite{BurnimS08} to generate a batch of $k$ decision vectors, as described in Chapter \ref{ch:eq}. As \textsc{Crest} might fail to generate the decision vector of a program execution due to abnormal termination of the execution, we modified \textsc{Crest} to take a prefix of the execution in finite length in this case. An issue of \textsc{Crest} we encountered is that when proposed a condition comprising Boolean connectives, it expands the condition into a cascade of \texttt{if} statements corresponding to the Boolean expression, thus increasing the size of the program and making it even harder to learn. We addressed this by modifying \textsc{Crest} so that it can process conditions containing Boolean connectives without expanding them, and consequently increased the performance and precision of the analysis. 

We also implemented the following three optimizations to improve the performance of \PACMAN under synthesize-and-verify mode.